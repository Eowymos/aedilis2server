using System;
using System.Collections;
using System.Xml.Serialization;
using System.IO;

using Server;
using Server.Mobiles;
using Server.Items;

namespace Arya.DialogEditor
{
	/// <summary>
	/// Summary description for DialogNPC.
	/// </summary>
	public class DialogNPC : BaseCreature
	{
		/// <summary>
		/// This is the folder where the XML configuration files are stored.
		/// This path is considered based at the RunUO folder.
		/// </summary>
		private static string m_XmlFolder = @"Scripts\Custom Scripts\Npcs\DialogNPC\Dialog";

		#region Variables

		/// <summary>
		/// The configuration object for this NPC
		/// </summary>
		private DialogEditor.Dialog m_Dialog;
		/// <summary>
		/// The list of players that are currently viewing a gump generated by this NPC
		/// </summary>
		private ArrayList m_Users;
		/// <summary>
		/// The location of the configuration file used by this NPC
		/// </summary>
		private string m_FileName = null;
		/// <summary>
		/// Specifies whether the NPC will react to players or not
		/// </summary>
		private bool m_Active = false;
		/// <summary>
		/// Specifies if the current configuration needs to handle speech
		/// </summary>
		private bool m_HandleSpeech;
		/// <summary>
		/// Specifies if the current configuration needs to handle double clicks
		/// </summary>
		private bool m_HandleDblClick;
		/// <summary>
		/// Specifies if the current configuration needs to handle items given
		/// </summary>
		private bool m_HandleItemGiven;
		/// <summary>
		/// Specifies if the current configuration needs to handle items in backpack
		/// </summary>
		private bool m_HandleItem;

		#endregion

		#region Properties

		[ CommandProperty( AccessLevel.GameMaster ) ]
		/// <summary>
		/// States whether the NPC is active and can react to players
		/// </summary>
		public bool Active
		{
			get { return m_Active; }
			set
			{
				m_Active = value && m_Dialog != null && m_Dialog.Init.Count > 0;
			}
		}

		[ CommandProperty( AccessLevel.GameMaster ) ]
		/// <summary>
		/// Gets the name of the XML file used to currently configure the NPC
		/// </summary>
		public string DialogName
		{
			get
			{
				if ( m_FileName == null || ! File.Exists( m_FileName ) )
					return "None";
				else
					return Path.GetFileNameWithoutExtension( m_FileName );
			}
		}

		/// <summary>
		/// Gets the list of all configuration files available for a DialogNPC
		/// </summary>
		public static string[] ConfigurationFiles
		{
			get
			{
				string directory = Path.Combine( Core.BaseDirectory, m_XmlFolder );

				if ( ! Directory.Exists( directory ) )
					return null;

				return Directory.GetFiles( directory, "*.xml" );
			}
		}

		#endregion

		[ Constructable ]
		public DialogNPC() : base( AIType.AI_Thief, FightMode.None, 10, 1, 0.8, 1.6 )
		{
			m_Users = new ArrayList();
			EventSink.Disconnected += new DisconnectedEventHandler(OnPlayerDisconnected);

			CantWalk = true;
			Hidden = true;

			InitStats( 100, 25, 100 );

			if ( Female == Utility.RandomBool() )
			{
				// Female
				Name = NameList.RandomName( "female" );
				Body = 0x191;
			}
			else
			{
				Name = NameList.RandomName( "male" );
				Body = 0x190;
			}

			Blessed = true;
			RangeHome = 5;

			InitOutfit();
		}

		#region Outfit

		private void InitOutfit()
		{
			switch ( Utility.Random( 3 ) )
			{
				case 0: AddItem( new FancyShirt( GetRandomHue() ) ); break;
				case 1: AddItem( new Doublet( GetRandomHue() ) ); break;
				case 2: AddItem( new Shirt( GetRandomHue() ) ); break;
			}

			switch ( ShoeType )
			{
				case VendorShoeType.Shoes: AddItem( new Shoes( GetShoeHue() ) ); break;
				case VendorShoeType.Boots: AddItem( new Boots( GetShoeHue() ) ); break;
				case VendorShoeType.Sandals: AddItem( new Sandals( GetShoeHue() ) ); break;
				case VendorShoeType.ThighBoots: AddItem( new ThighBoots( GetShoeHue() ) ); break;
			}

			int hairHue = Utility.RandomHairHue();

			if ( Female )
			{
				switch ( Utility.Random( 6 ) )
				{
					case 0: AddItem( new ShortPants( GetRandomHue() ) ); break;
					case 1:
					case 2: AddItem( new Kilt( GetRandomHue() ) ); break;
					case 3:
					case 4:
					case 5: AddItem( new Skirt( GetRandomHue() ) ); break;
				}

				switch ( Utility.Random( 9 ) )
				{
					case 0: AddItem( new Afro( hairHue ) ); break;
					case 1: AddItem( new KrisnaHair( hairHue ) ); break;
					case 2: AddItem( new PageboyHair( hairHue ) ); break;
					case 3: AddItem( new PonyTail( hairHue ) ); break;
					case 4: AddItem( new ReceedingHair( hairHue ) ); break;
					case 5: AddItem( new TwoPigTails( hairHue ) ); break;
					case 6: AddItem( new ShortHair( hairHue ) ); break;
					case 7: AddItem( new LongHair( hairHue ) ); break;
					case 8: AddItem( new BunsHair( hairHue ) ); break;
				}
			}
			else
			{
				switch ( Utility.Random( 2 ) )
				{
					case 0: AddItem( new LongPants( GetRandomHue() ) ); break;
					case 1: AddItem( new ShortPants( GetRandomHue() ) ); break;
				}

				switch ( Utility.Random( 8 ) )
				{
					case 0: AddItem( new Afro( hairHue ) ); break;
					case 1: AddItem( new KrisnaHair( hairHue ) ); break;
					case 2: AddItem( new PageboyHair( hairHue ) ); break;
					case 3: AddItem( new PonyTail( hairHue ) ); break;
					case 4: AddItem( new ReceedingHair( hairHue ) ); break;
					case 5: AddItem( new TwoPigTails( hairHue ) ); break;
					case 6: AddItem( new ShortHair( hairHue ) ); break;
					case 7: AddItem( new LongHair( hairHue ) ); break;
				}

				switch ( Utility.Random( 5 ) )
				{
					case 0: AddItem( new LongBeard( hairHue ) ); break;
					case 1: AddItem( new MediumLongBeard( hairHue ) ); break;
					case 2: AddItem( new Vandyke( hairHue ) ); break;
					case 3: AddItem( new Mustache( hairHue ) ); break;
					case 4: AddItem( new Goatee( hairHue ) ); break;
				}
			}
		}

		private int GetRandomHue()
		{
			switch ( Utility.Random( 5 ) )
			{
				default:
				case 0: return Utility.RandomBlueHue();
				case 1: return Utility.RandomGreenHue();
				case 2: return Utility.RandomRedHue();
				case 3: return Utility.RandomYellowHue();
				case 4: return Utility.RandomNeutralHue();
			}
		}

		private int GetShoeHue()
		{
			if ( 0.1 > Utility.RandomDouble() )
				return 0;

			return Utility.RandomNeutralHue();
		}

		private VendorShoeType ShoeType
		{
			get{ return VendorShoeType.Shoes; }
		}

		#endregion

		#region Serialization

		public DialogNPC( Serial serial ) : base( serial )
		{
			m_Users = new ArrayList();
		}

		public override void Serialize(GenericWriter writer)
		{
			base.Serialize (writer);

			writer.Write( 0 ); // Version

			writer.Write( m_FileName );
			writer.Write( m_Active );
		}

		public override void Deserialize(GenericReader reader)
		{
			base.Deserialize (reader);

			int version = reader.ReadInt();

			m_FileName = reader.ReadString();
			m_Active = reader.ReadBool();

			Configure( null );

			EventSink.Disconnected += new DisconnectedEventHandler(OnPlayerDisconnected);
		}

		#endregion

		/// <summary>
		/// When player disconnects, remove it from the current users
		/// </summary>
		private void OnPlayerDisconnected(DisconnectedEventArgs e)
		{
			if ( m_Users.Contains( e.Mobile ) )
				m_Users.Remove( e.Mobile );
		}

		#region Configuration

		/// <summary>
		/// Sets the filename used to configure the NPC
		/// </summary>
		/// <param name="file">The filename - set to null to clear NPC</param>
		/// <param name="m">The mobile configuring the NPC</param>
		public void SetFileName( string file, Mobile m )
		{
			m_FileName = file;

			Configure( m );

			if ( m_FileName == null )
			{
				m_Dialog = null;
				m_Active = false;
				m_Users.Clear();
			}
		}

		/// <summary>
		/// Configures the NPC with the selected file
		/// </summary>
		/// <param name="m">The mobile configuring the NPC. This can be null.</param>
		private void Configure( Mobile m )
		{
			if ( m_FileName == null || ! File.Exists( m_FileName ) )
			{
				return;
			}

			m_Dialog = Dialog.Load( m_FileName );

			if ( m_Dialog == null && m != null )
			{
				SendMessage( 0x40, "The selected file is not a valid configuration." );
			}

			m_Active = true;

			CalculateReactions();
		}

		/// <summary>
		/// Reads all dialog inits and sets flags so that the NPC knows what events not to handle
		/// </summary>
		private void CalculateReactions()
		{
			m_HandleItem = false;
			m_HandleItemGiven = false;
			m_HandleDblClick = false;
			m_HandleSpeech = false;

			if ( m_Dialog == null )
				return;

			foreach( DialogInit init in m_Dialog.Init )
			{
				m_HandleSpeech |= ( init.ReactToKeywords && init.Keywords.Length > 0 );
				m_HandleDblClick |= init.ReactToDoubleClick;
				m_HandleItem |= ( init.ReactToItemInBackpack && init.TypeBackpack != null && init.TypeBackpack.Length > 0 );
				m_HandleItemGiven |= ( init.ReactToItemGiven && init.TypeGiven != null && init.TypeGiven.Length > 0 );
			}

			Hidden = ! Active;
			CantWalk = ! Active;
		}

		#endregion

		#region Handlers for NPC reactions

		public override bool HandlesOnSpeech(Mobile from)
		{
			if ( ! m_HandleSpeech || m_Dialog == null || !Active )
				return false;

			if ( m_Users.Contains( from ) )
				return false;

			if ( ! from.CheckAlive( false ) )
				return false;

			return from.InRange( this.Location, m_Dialog.SpeechRange );
		}

		public override void OnSpeech(SpeechEventArgs e)
		{
			if ( m_Dialog == null )
				return;

			DialogInit match = null;

			foreach( DialogInit init in m_Dialog.Init )
			{
				if ( init.ReactToKeywords )
				{ 
					foreach( string key in init.Keywords )
					{
						if ( e.Speech.IndexOf( key ) > -1 )
						{
							match = init;
							break;
						}
					}

					if ( match != null )
						break;
				}
			}

			if ( match != null )
			{
				e.Handled = true;
				StartConversation( e.Mobile, match );
			}
		}

		public override bool OnDragDrop(Mobile from, Item dropped)
		{
			if ( m_Dialog == null || ! m_HandleItemGiven || ! Active || m_Users.Contains( from ) )
			{
				this.SayTo( from, "*shakes head*" );
				return false;
			}

			DialogInit match = null;

			foreach( DialogInit init in m_Dialog.Init )
			{
				if ( init.ReactToItemGiven && init.ItemGivenType != null )
				{
					if ( dropped.GetType() == init.ItemGivenType && dropped.Amount >= init.AmountGiven )
					{
						match = init;
						break;
					}
				}
			}

			if ( match != null )
			{
				StartConversation( from, match );

				// If dropped more than needed, just take what's required
				if ( dropped.Amount > match.AmountGiven )
				{
					dropped.Amount -= match.AmountGiven;
					return false;
				}
				else
				{
					return true;
				}
			}
			else
			{
				this.SayTo( from, "*shakes head*" );
				return false;
			}
		}

		public override void OnMovement(Mobile m, Point3D oldLocation)
		{
			if ( !m.Player || m_Dialog == null || ! m_HandleItem || ! Active || m_Users.Contains( m ) || !m.CheckAlive( false ) )
			{
				base.OnMovement( m, oldLocation );
				return;
			}

			// Trigger only when entering the range region: oldLocation not in range and new location in range

			if ( ! ( this.InRange( m.Location, m_Dialog.Range ) && ! this.InRange( oldLocation, m_Dialog.Range ) ) )
			{
				base.OnMovement( m, oldLocation );
				return;
			}

			DialogInit match = null;

			foreach( DialogInit init in m_Dialog.Init )
			{
				if ( init.ReactToItemInBackpack && init.ItemType != null && m.Backpack != null )
				{
					Item target = m.Backpack.FindItemByType( init.ItemType, true );

					if ( target != null )
					{
						if ( target.Amount >= init.AmountBackpack )
						{
							match = init;
							break;
						}
					}
				}
			}

			if ( match != null )
			{
				StartConversation( m, match );
			}
			else
			{
				base.OnMovement (m, oldLocation);
			}
		}

		public override void OnDoubleClick(Mobile from)
		{
			if ( from.AccessLevel >= AccessLevel.GameMaster )
			{
				from.SendGump( new FileSelectionGump( this, from ) );
			}

			if ( !m_HandleDblClick || m_Dialog == null || !Active || m_Users.Contains( from ) || ! from.CheckAlive( false ) )
				return;

			DialogInit match = null;

			foreach( DialogInit init in m_Dialog.Init )
			{
				if ( init.ReactToDoubleClick )
				{
					match = init;
					break;
				}
			}

			if ( match != null )
			{
				StartConversation( from, match );
			}
		}

		#endregion

		#region Gump Logic

		/// <summary>
		/// This function verifies if there is still a valid dialog. Staff might re-configure the NPC while a player might be using it.
		/// </summary>
		/// <param name="m">The mobile that is using the NPC</param>
		/// <returns>True if the NPC is still functional, False otherwise</returns>
		private bool Verify( Mobile m )
		{
			if ( m_Dialog == null )
			{
				m.SendMessage( 0x40, "This NPC is no longer functional. Please try again later." );
			}

			return m_Dialog != null;
		}

		/// <summary>
		/// Verifies if a speech is valid. This because some might used un-verified configurations.
		/// </summary>
		/// <param name="m">The mobile using the NPC</param>
		/// <param name="speech">The speech object being checked</param>
		/// <returns>True if the speech exists, false if it's null</returns>
		private bool VerifySpeech( Mobile m, DialogSpeech speech )
		{
			if ( speech == null )
			{
				m.SendMessage( 0x40, "The script for this NPC is incorrect. Please contact a Game Master and inform that the script '{0}' is bugged.", DialogName );
			}

			return speech != null;
		}

		/// <summary>
		/// Begins a conversation with a player by sending them the first gump
		/// </summary>
		/// <param name="m">The mobile beginning the conversation</param>
		/// <param name="init">The DialogInit object specifying the starting condition</param>
		private void StartConversation( Mobile m, DialogInit init )
		{
			if ( ! Verify( m ) )
				return;

			DialogSpeech speech = m_Dialog.GetSpeech( init.Speech );

			if ( ! VerifySpeech( m, speech ) )
				return;

			m_Users.Add( m );

			SendSpeechGump( speech, m );
		}

		/// <summary>
		/// Performs a choice after it's been selected by a user
		/// </summary>
		/// <param name="m">The user of the conversation</param>
		/// <param name="choice">The choice selected through the gump</param>
		public void PerformChoice( Mobile m, DialogChoice choice )
		{
			if ( ! Verify( m ) )
				return;

			if ( choice.Invoke )
			{
				choice.PerformInvoke( m, this );
			}

			if ( choice.EndDialog )
			{
				m_Users.Remove( m );
				return;
			}

			DialogSpeech speech = m_Dialog.GetSpeech( choice.ChoiceID );

			if ( ! VerifySpeech( m, speech ) )
			{
				m_Users.Remove( m );
				return;
			}

			SendSpeechGump( speech, m );
		}

		/// <summary>
		/// Sends the actual speech gump
		/// </summary>
		/// <param name="speech">The speech object being displayed</param>
		/// <param name="m">The player receiving the gump</param>
		private void SendSpeechGump( DialogSpeech speech, Mobile m )
		{
			ArrayList choices = new ArrayList();

			foreach( Guid id in speech.Choices )
			{
				DialogChoice c = m_Dialog.GetChoice( id );

				if ( c != null )
					choices.Add( c );
			}

			m.SendGump( new ConversationGump( m_Dialog, speech, choices, this, m ) );
		}

		/// <summary>
		/// Sends the specified player the speech identified by the specified ID.
		/// This function will do nothing if the ID isn't valid for this Dialog, and should be only called
		/// from external functions
		/// </summary>
		/// <param name="guid">The string representation of the unique GUID of the speech that should be displayed</param>
		/// <param name="m">The Mobile who should receive the speech</param>
		public void RunSpeechGump( string guid, Mobile m )
		{
			try
			{
				Guid id = new Guid( guid );
				RunSpeechGump( id, m );
			}
			catch{}
		}

		/// <summary>
		/// Sends the specified player the speech identified by the specified ID.
		/// This function will do nothing if the ID isn't valid for this Dialog, and should be only called
		/// from external functions
		/// </summary>
		/// <param name="guid">The unique GUID of the speech that should be displayed</param>
		/// <param name="m">The Mobile who should receive the speech</param>
		public void RunSpeechGump( Guid guid, Mobile m )
		{
			if ( ! Verify( m ) )
				return;

			DialogSpeech speech = m_Dialog.GetSpeech( guid );

			if ( ! VerifySpeech( m, speech ) )
				return;

			SendSpeechGump( speech, m );
		}

		/// <summary>
		/// This function ends the conversation when the user chooses the End Conversation button on the gump
		/// </summary>
		/// <param name="m">The user closing the conversation</param>
		public void EndConversation( Mobile m )
		{
			if ( m_Users.Contains( m ) )
				m_Users.Remove( m );
		}

		#endregion
	}
}